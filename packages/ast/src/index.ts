/**
 * @autogenerated
 */

import AnyObjectTypeAnnotation from './nodes/AnyObjectTypeAnnotation';
import AnyTypeAnnotation from './nodes/AnyTypeAnnotation';
import ArrayExpression from './nodes/ArrayExpresison';
import ArrayPattern from './nodes/ArrayPattern';
import ArrayTypeAnnotation from './nodes/ArrayTypeAnnotation';
import AssignmentExpression from './nodes/AssignmentExpression';
import AssignmentPattern from './nodes/AssignmentPattern';
import BinaryExpression from './nodes/BinaryExpression';
import BooleanTypeAnnotation from './nodes/BooleanTypeAnnotation';
import EmptyTypeAnnotation from './nodes/EmptyTypeAnnotation';
import ExistsTypeAnnotation from './nodes/ExistsTypeAnnotation';
import ExportDefault from './nodes/ExportDefault';
import ExportNamed from './nodes/ExportNamed';
import ExpressionStatement from './nodes/ExpressionStatement';
import File from './nodes/File';
import FunctionDeclaration from './nodes/FunctionDeclaration';
import FunctionParameter from './nodes/FunctionParameter';
import FunctionTypeAnnotation from './nodes/FunctionTypeAnnotation';
import Identifier from './nodes/Identifier';
import IfStatement from './nodes/IfStatement';
import {EsImportSource} from './nodes/ImportStatement';
import {CommonJSImportSource} from './nodes/ImportStatement';
import {NamespaceImportSource} from './nodes/ImportStatement';
import ImportStatement from './nodes/ImportStatement';
import ImportTypeAnnotation from './nodes/ImportTypeAnnotation';
import InferTypeAnnotation from './nodes/InferTypeAnnotation';
import IntersectionTypeAnnotation from './nodes/IntersectionTypeAnnotation';
import LiteralTypeAnnotation from './nodes/LiteralTypeAnnotation';
import LogicalExpression from './nodes/LogicalExpression';
import NullLiteralTypeAnnotation from './nodes/NullLiteralTypeAnnotation';
import NumberTypeAnnotation from './nodes/NumberTypeAnnotation';
import ObjectPattern from './nodes/ObjectPattern';
import {ObjectTypeProperty} from './nodes/ObjectTypeAnnotation';
import {ObjectTypeIndexer} from './nodes/ObjectTypeAnnotation';
import {ObjectTypeSpreadProperty} from './nodes/ObjectTypeAnnotation';
import ObjectTypeAnnotation from './nodes/ObjectTypeAnnotation';
import QualifiedTypeIdentifier from './nodes/QualifiedTypeIdentifier';
import ReturnStatement from './nodes/ReturnStatement';
import SpreadElement from './nodes/SpreadElement';
import StringTypeAnnotation from './nodes/StringTypeAnnotation';
import SymbolTypeAnnotation from './nodes/SymbolTypeAnnotation';
import ThisTypeAnnotation from './nodes/ThisTypeAnnotation';
import TupleTypeAnnotation from './nodes/TupleTypeAnnotation';
import TypeAliasDeclaration from './nodes/TypeAliasDeclaration';
import TypeParameter from './nodes/TypeParameter';
import TypeReferenceAnnotation from './nodes/TypeReferenceAnnotation';
import TypeofTypeAnnotation from './nodes/TypeofTypeAnnotation';
import UnionTypeAnnotation from './nodes/UnionTypeAnnotation';
import UnknownTypeAnnotation from './nodes/UnknownTypeAnnotation';
import VoidTypeAnnotation from './nodes/VoidTypeAnnotation';
import Node from './aliases/Node';
import TypeAnnotation from './aliases/TypeAnnotation';
import Expression from './aliases/Expression';
import LVal from './aliases/LVal';
import Pattern from './aliases/Pattern';
import Statement from './aliases/Statement';
import Declaration from './aliases/Declaration';
import ValueDeclaration from './aliases/ValueDeclaration';
import ImportSource from './aliases/ImportSource';
import ObjectTypeElement from './aliases/ObjectTypeElement';
import TypeDeclaration from './aliases/TypeDeclaration';
import Comment, {CommentKind} from './Comment';
import NodeBase from './NodeBase';
import NodeKind from './NodeKind';
import SourceLocation from './SourceLocation';
import Variance from './Variance';

export {AnyObjectTypeAnnotation};
export {AnyTypeAnnotation};
export {ArrayExpression};
export {ArrayPattern};
export {ArrayTypeAnnotation};
export {AssignmentExpression};
export {AssignmentPattern};
export {BinaryExpression};
export {BooleanTypeAnnotation};
export {EmptyTypeAnnotation};
export {ExistsTypeAnnotation};
export {ExportDefault};
export {ExportNamed};
export {ExpressionStatement};
export {File};
export {FunctionDeclaration};
export {FunctionParameter};
export {FunctionTypeAnnotation};
export {Identifier};
export {IfStatement};
export {EsImportSource};
export {CommonJSImportSource};
export {NamespaceImportSource};
export {ImportStatement};
export {ImportTypeAnnotation};
export {InferTypeAnnotation};
export {IntersectionTypeAnnotation};
export {LiteralTypeAnnotation};
export {LogicalExpression};
export {NullLiteralTypeAnnotation};
export {NumberTypeAnnotation};
export {ObjectPattern};
export {ObjectTypeProperty};
export {ObjectTypeIndexer};
export {ObjectTypeSpreadProperty};
export {ObjectTypeAnnotation};
export {QualifiedTypeIdentifier};
export {ReturnStatement};
export {SpreadElement};
export {StringTypeAnnotation};
export {SymbolTypeAnnotation};
export {ThisTypeAnnotation};
export {TupleTypeAnnotation};
export {TypeAliasDeclaration};
export {TypeParameter};
export {TypeReferenceAnnotation};
export {TypeofTypeAnnotation};
export {UnionTypeAnnotation};
export {UnknownTypeAnnotation};
export {VoidTypeAnnotation};
export {Node};
export {TypeAnnotation};
export {Expression};
export {LVal};
export {Pattern};
export {Statement};
export {Declaration};
export {ValueDeclaration};
export {ImportSource};
export {ObjectTypeElement};
export {TypeDeclaration};
export {Comment, CommentKind}
export {NodeBase};
export {NodeKind};
export {SourceLocation};
export {Variance};

export function createAnyObjectTypeAnnotation(props: Omit<AnyObjectTypeAnnotation, 'kind'>): AnyObjectTypeAnnotation {
  return {...props, kind: NodeKind.AnyObjectTypeAnnotation};
}
export function createAnyTypeAnnotation(props: Omit<AnyTypeAnnotation, 'kind'>): AnyTypeAnnotation {
  return {...props, kind: NodeKind.AnyTypeAnnotation};
}
export function createArrayExpression(props: Omit<ArrayExpression, 'kind'>): ArrayExpression {
  return {...props, kind: NodeKind.ArrayExpression};
}
export function createArrayPattern(props: Omit<ArrayPattern, 'kind'>): ArrayPattern {
  return {...props, kind: NodeKind.ArrayPattern};
}
export function createArrayTypeAnnotation(props: Omit<ArrayTypeAnnotation, 'kind'>): ArrayTypeAnnotation {
  return {...props, kind: NodeKind.ArrayTypeAnnotation};
}
export function createAssignmentExpression(props: Omit<AssignmentExpression, 'kind'>): AssignmentExpression {
  return {...props, kind: NodeKind.AssignmentExpression};
}
export function createAssignmentPattern(props: Omit<AssignmentPattern, 'kind'>): AssignmentPattern {
  return {...props, kind: NodeKind.AssignmentPattern};
}
export function createBinaryExpression(props: Omit<BinaryExpression, 'kind'>): BinaryExpression {
  return {...props, kind: NodeKind.BinaryExpression};
}
export function createBooleanTypeAnnotation(props: Omit<BooleanTypeAnnotation, 'kind'>): BooleanTypeAnnotation {
  return {...props, kind: NodeKind.BooleanTypeAnnotation};
}
export function createEmptyTypeAnnotation(props: Omit<EmptyTypeAnnotation, 'kind'>): EmptyTypeAnnotation {
  return {...props, kind: NodeKind.EmptyTypeAnnotation};
}
export function createExistsTypeAnnotation(props: Omit<ExistsTypeAnnotation, 'kind'>): ExistsTypeAnnotation {
  return {...props, kind: NodeKind.ExistsTypeAnnotation};
}
export function createExportDefault(props: Omit<ExportDefault, 'kind'>): ExportDefault {
  return {...props, kind: NodeKind.ExportDefault};
}
export function createExportNamed(props: Omit<ExportNamed, 'kind'>): ExportNamed {
  return {...props, kind: NodeKind.ExportNamed};
}
export function createExpressionStatement(props: Omit<ExpressionStatement, 'kind'>): ExpressionStatement {
  return {...props, kind: NodeKind.ExpressionStatement};
}
export function createFile(props: Omit<File, 'kind'>): File {
  return {...props, kind: NodeKind.File};
}
export function createFunctionDeclaration(props: Omit<FunctionDeclaration, 'kind'>): FunctionDeclaration {
  return {...props, kind: NodeKind.FunctionDeclaration};
}
export function createFunctionParameter(props: Omit<FunctionParameter, 'kind'>): FunctionParameter {
  return {...props, kind: NodeKind.FunctionParameter};
}
export function createFunctionTypeAnnotation(props: Omit<FunctionTypeAnnotation, 'kind'>): FunctionTypeAnnotation {
  return {...props, kind: NodeKind.FunctionTypeAnnotation};
}
export function createIdentifier(props: Omit<Identifier, 'kind'>): Identifier {
  return {...props, kind: NodeKind.Identifier};
}
export function createIfStatement(props: Omit<IfStatement, 'kind'>): IfStatement {
  return {...props, kind: NodeKind.IfStatement};
}
export function createEsImportSource(props: Omit<EsImportSource, 'kind'>): EsImportSource {
  return {...props, kind: NodeKind.EsImportSource};
}
export function createCommonJSImportSource(props: Omit<CommonJSImportSource, 'kind'>): CommonJSImportSource {
  return {...props, kind: NodeKind.CommonJSImportSource};
}
export function createNamespaceImportSource(props: Omit<NamespaceImportSource, 'kind'>): NamespaceImportSource {
  return {...props, kind: NodeKind.NamespaceImportSource};
}
export function createImportStatement(props: Omit<ImportStatement, 'kind'>): ImportStatement {
  return {...props, kind: NodeKind.ImportStatement};
}
export function createImportTypeAnnotation(props: Omit<ImportTypeAnnotation, 'kind'>): ImportTypeAnnotation {
  return {...props, kind: NodeKind.ImportTypeAnnotation};
}
export function createInferTypeAnnotation(props: Omit<InferTypeAnnotation, 'kind'>): InferTypeAnnotation {
  return {...props, kind: NodeKind.InferTypeAnnotation};
}
export function createIntersectionTypeAnnotation(props: Omit<IntersectionTypeAnnotation, 'kind'>): IntersectionTypeAnnotation {
  return {...props, kind: NodeKind.IntersectionTypeAnnotation};
}
export function createLiteralTypeAnnotation(props: Omit<LiteralTypeAnnotation, 'kind'>): LiteralTypeAnnotation {
  return {...props, kind: NodeKind.LiteralTypeAnnotation};
}
export function createLogicalExpression(props: Omit<LogicalExpression, 'kind'>): LogicalExpression {
  return {...props, kind: NodeKind.LogicalExpression};
}
export function createNullLiteralTypeAnnotation(props: Omit<NullLiteralTypeAnnotation, 'kind'>): NullLiteralTypeAnnotation {
  return {...props, kind: NodeKind.NullLiteralTypeAnnotation};
}
export function createNumberTypeAnnotation(props: Omit<NumberTypeAnnotation, 'kind'>): NumberTypeAnnotation {
  return {...props, kind: NodeKind.NumberTypeAnnotation};
}
export function createObjectPattern(props: Omit<ObjectPattern, 'kind'>): ObjectPattern {
  return {...props, kind: NodeKind.ObjectPattern};
}
export function createObjectTypeProperty(props: Omit<ObjectTypeProperty, 'kind'>): ObjectTypeProperty {
  return {...props, kind: NodeKind.ObjectTypeProperty};
}
export function createObjectTypeIndexer(props: Omit<ObjectTypeIndexer, 'kind'>): ObjectTypeIndexer {
  return {...props, kind: NodeKind.ObjectTypeIndexer};
}
export function createObjectTypeSpreadProperty(props: Omit<ObjectTypeSpreadProperty, 'kind'>): ObjectTypeSpreadProperty {
  return {...props, kind: NodeKind.ObjectTypeSpreadProperty};
}
export function createObjectTypeAnnotation(props: Omit<ObjectTypeAnnotation, 'kind'>): ObjectTypeAnnotation {
  return {...props, kind: NodeKind.ObjectTypeAnnotation};
}
export function createQualifiedTypeIdentifier(props: Omit<QualifiedTypeIdentifier, 'kind'>): QualifiedTypeIdentifier {
  return {...props, kind: NodeKind.QualifiedTypeIdentifier};
}
export function createReturnStatement(props: Omit<ReturnStatement, 'kind'>): ReturnStatement {
  return {...props, kind: NodeKind.ReturnStatement};
}
export function createSpreadElement(props: Omit<SpreadElement, 'kind'>): SpreadElement {
  return {...props, kind: NodeKind.SpreadElement};
}
export function createStringTypeAnnotation(props: Omit<StringTypeAnnotation, 'kind'>): StringTypeAnnotation {
  return {...props, kind: NodeKind.StringTypeAnnotation};
}
export function createSymbolTypeAnnotation(props: Omit<SymbolTypeAnnotation, 'kind'>): SymbolTypeAnnotation {
  return {...props, kind: NodeKind.SymbolTypeAnnotation};
}
export function createThisTypeAnnotation(props: Omit<ThisTypeAnnotation, 'kind'>): ThisTypeAnnotation {
  return {...props, kind: NodeKind.ThisTypeAnnotation};
}
export function createTupleTypeAnnotation(props: Omit<TupleTypeAnnotation, 'kind'>): TupleTypeAnnotation {
  return {...props, kind: NodeKind.TupleTypeAnnotation};
}
export function createTypeAliasDeclaration(props: Omit<TypeAliasDeclaration, 'kind'>): TypeAliasDeclaration {
  return {...props, kind: NodeKind.TypeAliasDeclaration};
}
export function createTypeParameter(props: Omit<TypeParameter, 'kind'>): TypeParameter {
  return {...props, kind: NodeKind.TypeParameter};
}
export function createTypeReferenceAnnotation(props: Omit<TypeReferenceAnnotation, 'kind'>): TypeReferenceAnnotation {
  return {...props, kind: NodeKind.TypeReferenceAnnotation};
}
export function createTypeofTypeAnnotation(props: Omit<TypeofTypeAnnotation, 'kind'>): TypeofTypeAnnotation {
  return {...props, kind: NodeKind.TypeofTypeAnnotation};
}
export function createUnionTypeAnnotation(props: Omit<UnionTypeAnnotation, 'kind'>): UnionTypeAnnotation {
  return {...props, kind: NodeKind.UnionTypeAnnotation};
}
export function createUnknownTypeAnnotation(props: Omit<UnknownTypeAnnotation, 'kind'>): UnknownTypeAnnotation {
  return {...props, kind: NodeKind.UnknownTypeAnnotation};
}
export function createVoidTypeAnnotation(props: Omit<VoidTypeAnnotation, 'kind'>): VoidTypeAnnotation {
  return {...props, kind: NodeKind.VoidTypeAnnotation};
}

export function isAnyObjectTypeAnnotation(node: Node): node is AnyObjectTypeAnnotation {
  return node.kind === NodeKind.AnyObjectTypeAnnotation;
}
export function isAnyTypeAnnotation(node: Node): node is AnyTypeAnnotation {
  return node.kind === NodeKind.AnyTypeAnnotation;
}
export function isArrayExpression(node: Node): node is ArrayExpression {
  return node.kind === NodeKind.ArrayExpression;
}
export function isArrayPattern(node: Node): node is ArrayPattern {
  return node.kind === NodeKind.ArrayPattern;
}
export function isArrayTypeAnnotation(node: Node): node is ArrayTypeAnnotation {
  return node.kind === NodeKind.ArrayTypeAnnotation;
}
export function isAssignmentExpression(node: Node): node is AssignmentExpression {
  return node.kind === NodeKind.AssignmentExpression;
}
export function isAssignmentPattern(node: Node): node is AssignmentPattern {
  return node.kind === NodeKind.AssignmentPattern;
}
export function isBinaryExpression(node: Node): node is BinaryExpression {
  return node.kind === NodeKind.BinaryExpression;
}
export function isBooleanTypeAnnotation(node: Node): node is BooleanTypeAnnotation {
  return node.kind === NodeKind.BooleanTypeAnnotation;
}
export function isEmptyTypeAnnotation(node: Node): node is EmptyTypeAnnotation {
  return node.kind === NodeKind.EmptyTypeAnnotation;
}
export function isExistsTypeAnnotation(node: Node): node is ExistsTypeAnnotation {
  return node.kind === NodeKind.ExistsTypeAnnotation;
}
export function isExportDefault(node: Node): node is ExportDefault {
  return node.kind === NodeKind.ExportDefault;
}
export function isExportNamed(node: Node): node is ExportNamed {
  return node.kind === NodeKind.ExportNamed;
}
export function isExpressionStatement(node: Node): node is ExpressionStatement {
  return node.kind === NodeKind.ExpressionStatement;
}
export function isFile(node: Node): node is File {
  return node.kind === NodeKind.File;
}
export function isFunctionDeclaration(node: Node): node is FunctionDeclaration {
  return node.kind === NodeKind.FunctionDeclaration;
}
export function isFunctionParameter(node: Node): node is FunctionParameter {
  return node.kind === NodeKind.FunctionParameter;
}
export function isFunctionTypeAnnotation(node: Node): node is FunctionTypeAnnotation {
  return node.kind === NodeKind.FunctionTypeAnnotation;
}
export function isIdentifier(node: Node): node is Identifier {
  return node.kind === NodeKind.Identifier;
}
export function isIfStatement(node: Node): node is IfStatement {
  return node.kind === NodeKind.IfStatement;
}
export function isEsImportSource(node: Node): node is EsImportSource {
  return node.kind === NodeKind.EsImportSource;
}
export function isCommonJSImportSource(node: Node): node is CommonJSImportSource {
  return node.kind === NodeKind.CommonJSImportSource;
}
export function isNamespaceImportSource(node: Node): node is NamespaceImportSource {
  return node.kind === NodeKind.NamespaceImportSource;
}
export function isImportStatement(node: Node): node is ImportStatement {
  return node.kind === NodeKind.ImportStatement;
}
export function isImportTypeAnnotation(node: Node): node is ImportTypeAnnotation {
  return node.kind === NodeKind.ImportTypeAnnotation;
}
export function isInferTypeAnnotation(node: Node): node is InferTypeAnnotation {
  return node.kind === NodeKind.InferTypeAnnotation;
}
export function isIntersectionTypeAnnotation(node: Node): node is IntersectionTypeAnnotation {
  return node.kind === NodeKind.IntersectionTypeAnnotation;
}
export function isLiteralTypeAnnotation(node: Node): node is LiteralTypeAnnotation {
  return node.kind === NodeKind.LiteralTypeAnnotation;
}
export function isLogicalExpression(node: Node): node is LogicalExpression {
  return node.kind === NodeKind.LogicalExpression;
}
export function isNullLiteralTypeAnnotation(node: Node): node is NullLiteralTypeAnnotation {
  return node.kind === NodeKind.NullLiteralTypeAnnotation;
}
export function isNumberTypeAnnotation(node: Node): node is NumberTypeAnnotation {
  return node.kind === NodeKind.NumberTypeAnnotation;
}
export function isObjectPattern(node: Node): node is ObjectPattern {
  return node.kind === NodeKind.ObjectPattern;
}
export function isObjectTypeProperty(node: Node): node is ObjectTypeProperty {
  return node.kind === NodeKind.ObjectTypeProperty;
}
export function isObjectTypeIndexer(node: Node): node is ObjectTypeIndexer {
  return node.kind === NodeKind.ObjectTypeIndexer;
}
export function isObjectTypeSpreadProperty(node: Node): node is ObjectTypeSpreadProperty {
  return node.kind === NodeKind.ObjectTypeSpreadProperty;
}
export function isObjectTypeAnnotation(node: Node): node is ObjectTypeAnnotation {
  return node.kind === NodeKind.ObjectTypeAnnotation;
}
export function isQualifiedTypeIdentifier(node: Node): node is QualifiedTypeIdentifier {
  return node.kind === NodeKind.QualifiedTypeIdentifier;
}
export function isReturnStatement(node: Node): node is ReturnStatement {
  return node.kind === NodeKind.ReturnStatement;
}
export function isSpreadElement(node: Node): node is SpreadElement {
  return node.kind === NodeKind.SpreadElement;
}
export function isStringTypeAnnotation(node: Node): node is StringTypeAnnotation {
  return node.kind === NodeKind.StringTypeAnnotation;
}
export function isSymbolTypeAnnotation(node: Node): node is SymbolTypeAnnotation {
  return node.kind === NodeKind.SymbolTypeAnnotation;
}
export function isThisTypeAnnotation(node: Node): node is ThisTypeAnnotation {
  return node.kind === NodeKind.ThisTypeAnnotation;
}
export function isTupleTypeAnnotation(node: Node): node is TupleTypeAnnotation {
  return node.kind === NodeKind.TupleTypeAnnotation;
}
export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration {
  return node.kind === NodeKind.TypeAliasDeclaration;
}
export function isTypeParameter(node: Node): node is TypeParameter {
  return node.kind === NodeKind.TypeParameter;
}
export function isTypeReferenceAnnotation(node: Node): node is TypeReferenceAnnotation {
  return node.kind === NodeKind.TypeReferenceAnnotation;
}
export function isTypeofTypeAnnotation(node: Node): node is TypeofTypeAnnotation {
  return node.kind === NodeKind.TypeofTypeAnnotation;
}
export function isUnionTypeAnnotation(node: Node): node is UnionTypeAnnotation {
  return node.kind === NodeKind.UnionTypeAnnotation;
}
export function isUnknownTypeAnnotation(node: Node): node is UnknownTypeAnnotation {
  return node.kind === NodeKind.UnknownTypeAnnotation;
}
export function isVoidTypeAnnotation(node: Node): node is VoidTypeAnnotation {
  return node.kind === NodeKind.VoidTypeAnnotation;
}
export function isNode(node: Node): node is Node {
  return (node.kind === NodeKind.AnyObjectTypeAnnotation || node.kind === NodeKind.AnyTypeAnnotation || node.kind === NodeKind.ArrayExpression || node.kind === NodeKind.ArrayPattern || node.kind === NodeKind.ArrayTypeAnnotation || node.kind === NodeKind.AssignmentExpression || node.kind === NodeKind.AssignmentPattern || node.kind === NodeKind.BinaryExpression || node.kind === NodeKind.BooleanTypeAnnotation || node.kind === NodeKind.CommonJSImportSource || node.kind === NodeKind.EmptyTypeAnnotation || node.kind === NodeKind.EsImportSource || node.kind === NodeKind.ExistsTypeAnnotation || node.kind === NodeKind.ExportDefault || node.kind === NodeKind.ExportNamed || node.kind === NodeKind.ExpressionStatement || node.kind === NodeKind.File || node.kind === NodeKind.FunctionDeclaration || node.kind === NodeKind.FunctionParameter || node.kind === NodeKind.FunctionTypeAnnotation || node.kind === NodeKind.Identifier || node.kind === NodeKind.IfStatement || node.kind === NodeKind.ImportStatement || node.kind === NodeKind.ImportTypeAnnotation || node.kind === NodeKind.InferTypeAnnotation || node.kind === NodeKind.IntersectionTypeAnnotation || node.kind === NodeKind.LiteralTypeAnnotation || node.kind === NodeKind.LogicalExpression || node.kind === NodeKind.NamespaceImportSource || node.kind === NodeKind.NullLiteralTypeAnnotation || node.kind === NodeKind.NumberTypeAnnotation || node.kind === NodeKind.ObjectPattern || node.kind === NodeKind.ObjectTypeAnnotation || node.kind === NodeKind.ObjectTypeIndexer || node.kind === NodeKind.ObjectTypeProperty || node.kind === NodeKind.ObjectTypeSpreadProperty || node.kind === NodeKind.QualifiedTypeIdentifier || node.kind === NodeKind.ReturnStatement || node.kind === NodeKind.SpreadElement || node.kind === NodeKind.StringTypeAnnotation || node.kind === NodeKind.SymbolTypeAnnotation || node.kind === NodeKind.ThisTypeAnnotation || node.kind === NodeKind.TupleTypeAnnotation || node.kind === NodeKind.TypeAliasDeclaration || node.kind === NodeKind.TypeParameter || node.kind === NodeKind.TypeReferenceAnnotation || node.kind === NodeKind.TypeofTypeAnnotation || node.kind === NodeKind.UnionTypeAnnotation || node.kind === NodeKind.UnknownTypeAnnotation || node.kind === NodeKind.VoidTypeAnnotation);
}
export function isTypeAnnotation(node: Node): node is TypeAnnotation {
  return (node.kind === NodeKind.AnyObjectTypeAnnotation || node.kind === NodeKind.AnyTypeAnnotation || node.kind === NodeKind.ArrayTypeAnnotation || node.kind === NodeKind.BooleanTypeAnnotation || node.kind === NodeKind.EmptyTypeAnnotation || node.kind === NodeKind.ExistsTypeAnnotation || node.kind === NodeKind.FunctionTypeAnnotation || node.kind === NodeKind.Identifier || node.kind === NodeKind.ImportTypeAnnotation || node.kind === NodeKind.InferTypeAnnotation || node.kind === NodeKind.IntersectionTypeAnnotation || node.kind === NodeKind.LiteralTypeAnnotation || node.kind === NodeKind.NullLiteralTypeAnnotation || node.kind === NodeKind.NumberTypeAnnotation || node.kind === NodeKind.ObjectTypeAnnotation || node.kind === NodeKind.QualifiedTypeIdentifier || node.kind === NodeKind.StringTypeAnnotation || node.kind === NodeKind.SymbolTypeAnnotation || node.kind === NodeKind.ThisTypeAnnotation || node.kind === NodeKind.TupleTypeAnnotation || node.kind === NodeKind.TypeReferenceAnnotation || node.kind === NodeKind.TypeofTypeAnnotation || node.kind === NodeKind.UnionTypeAnnotation || node.kind === NodeKind.UnknownTypeAnnotation || node.kind === NodeKind.VoidTypeAnnotation);
}
export function isExpression(node: Node): node is Expression {
  return (node.kind === NodeKind.ArrayExpression || node.kind === NodeKind.AssignmentExpression || node.kind === NodeKind.BinaryExpression || node.kind === NodeKind.Identifier || node.kind === NodeKind.LogicalExpression);
}
export function isLVal(node: Node): node is LVal {
  return (node.kind === NodeKind.ArrayPattern || node.kind === NodeKind.AssignmentPattern || node.kind === NodeKind.Identifier || node.kind === NodeKind.ObjectPattern);
}
export function isPattern(node: Node): node is Pattern {
  return (node.kind === NodeKind.ArrayPattern || node.kind === NodeKind.AssignmentPattern || node.kind === NodeKind.Identifier || node.kind === NodeKind.ObjectPattern);
}
export function isStatement(node: Node): node is Statement {
  return (node.kind === NodeKind.ExportDefault || node.kind === NodeKind.ExportNamed || node.kind === NodeKind.ExpressionStatement || node.kind === NodeKind.FunctionDeclaration || node.kind === NodeKind.IfStatement || node.kind === NodeKind.ImportStatement || node.kind === NodeKind.ReturnStatement || node.kind === NodeKind.TypeAliasDeclaration);
}
export function isDeclaration(node: Node): node is Declaration {
  return (node.kind === NodeKind.FunctionDeclaration || node.kind === NodeKind.ImportStatement || node.kind === NodeKind.TypeAliasDeclaration);
}
export function isValueDeclaration(node: Node): node is ValueDeclaration {
  return (node.kind === NodeKind.FunctionDeclaration);
}
export function isImportSource(node: Node): node is ImportSource {
  return (node.kind === NodeKind.CommonJSImportSource || node.kind === NodeKind.EsImportSource || node.kind === NodeKind.NamespaceImportSource);
}
export function isObjectTypeElement(node: Node): node is ObjectTypeElement {
  return (node.kind === NodeKind.ObjectTypeIndexer || node.kind === NodeKind.ObjectTypeProperty || node.kind === NodeKind.ObjectTypeSpreadProperty);
}
export function isTypeDeclaration(node: Node): node is TypeDeclaration {
  return (node.kind === NodeKind.TypeAliasDeclaration);
}

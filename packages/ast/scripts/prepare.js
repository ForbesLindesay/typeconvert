const {resolve} = require('path');
const {readdirSync, readFileSync, writeFileSync} = require('fs');
const parser = require('@babel/parser');

const NodeLocations = new Map();
const Aliases = new Map();

readdirSync(__dirname + '/../src/nodes').forEach(fn => {
  const filename = resolve(__dirname + '/../src/nodes', fn);
  if (!/.*\.ts$/.test(filename)) return;
  const src = readFileSync(filename, 'utf8');
  const ast = parser.parse(src, {
    sourceType: 'module',
    sourceFilename: filename,
    plugins: [
      'jsx',
      'typescript',
      'doExpressions',
      'objectRestSpread',
      'classProperties',
      'classPrivateProperties',
      'classPrivateMethods',
      'exportDefaultFrom',
      'exportNamespaceFrom',
      'asyncGenerators',
      'functionBind',
      'dynamicImport',
      'numericSeparator',
      'optionalChaining',
      'bigInt',
      'optionalCatchBinding',
      'throwExpressions',
      'nullishCoalescingOperator',
    ],
  });
  ast.program.body.forEach(s =>
    walkStatement(s, s.leadingComments || [], null),
  );
  function walkStatement(statement, leadingComments, parentType) {
    switch (statement.type) {
      case 'ExportDefaultDeclaration':
      case 'ExportNamedDeclaration':
        walkStatement(
          statement.declaration,
          [
            ...leadingComments,
            ...(statement.declaration.leadingComments || []),
          ],
          statement.type,
        );
        break;
      case 'TSInterfaceDeclaration': {
        if (!parentType) {
          // ignore interfaces that are not exported
          return;
        }
        const name = `${statement.id.name}`;
        if (NodeLocations.has(name)) {
          throw new Error(
            `Duplicate interface ${name} declared in ${fn} and ${
              NodeLocations.get(name).file
            }`,
          );
        }
        NodeLocations.set(name, {
          file: fn,
          mode: parentType === 'ExportNamedDeclaration' ? 'name' : 'default',
        });
        const extendsNodeBase = (statement.extends || []).some(
          ex => ex.expression && ex.expression.name === 'NodeBase',
        );
        if (extendsNodeBase) {
          if (!Aliases.has('Node')) {
            Aliases.set('Node', []);
          }
          Aliases.get('Node').push(name);
        } else {
          console.warn('NOT A NODE: ' + name);
        }
        leadingComments.forEach(comment => {
          comment.value.replace(/\@alias ([^\n]+)/g, (_, aliasName) => {
            if (!Aliases.has(aliasName)) {
              Aliases.set(aliasName, []);
            }
            Aliases.get(aliasName).push(name);
          });
        });
        break;
      }
    }
  }
});

// console.log(Aliases);
Aliases.forEach((membersSet, aliasName) => {
  const members = [...membersSet].sort();
  writeFileSync(
    __dirname + `/../src/aliases/${aliasName}.ts`,
    [
      '/**',
      ' * @autogenerated',
      ' */',
      '',
      ...members.map(m => {
        const location = NodeLocations.get(m);
        return `import ${
          location.mode === 'default' ? `${m}` : `{${m}}`
        } from '../nodes/${location.file.replace(/\.ts$/, '')}';`;
      }),
      '',
      `type ${aliasName} = `,
      ...members.map(
        (m, i) => `  | ${m}` + (i === members.length - 1 ? ';' : ''),
      ),
      '',
      `export default ${aliasName};`,
      '',
    ].join('\n'),
  );
});

writeFileSync(
  __dirname + `/../src/index.ts`,
  [
    '/**',
    ' * @autogenerated',
    ' */',
    '',
    ...[...NodeLocations.keys()].map(m => {
      const location = NodeLocations.get(m);
      return `import ${
        location.mode === 'default' ? `${m}` : `{${m}}`
      } from './nodes/${location.file.replace(/\.ts$/, '')}';`;
    }),
    ...[...Aliases.keys()].map(aliasName => {
      return `import ${aliasName} from './aliases/${aliasName}';`;
    }),
    `import Comment, {CommentKind} from './Comment';`,
    `import NodeBase from './NodeBase';`,
    `import NodeKind from './NodeKind';`,
    `import SourceLocation from './SourceLocation';`,
    `import Variance from './Variance';`,
    '',
    ...[...NodeLocations.keys()].map(name => `export {${name}};`),
    ...[...Aliases.keys()].map(aliasName => {
      return `export {${aliasName}};`;
    }),
    `export {Comment, CommentKind}`,
    `export {NodeBase};`,
    `export {NodeKind};`,
    `export {SourceLocation};`,
    `export {Variance};`,
    '',

    ...[...NodeLocations.keys()].map(
      name => `export function create${name}(props: Omit<${name}, 'kind'>): ${name} {
  return {...props, kind: NodeKind.${name}};
}`,
    ),
    '',
    ...[...NodeLocations.keys()].map(
      name => `export function is${name}(node: Node): node is ${name} {
  return node.kind === NodeKind.${name};
}`,
    ),
    ...[...Aliases.keys()].map(
      name => `export function is${name}(node: Node): node is ${name} {
  return (${Aliases.get(name)
    .sort()
    .map(n => `node.kind === NodeKind.${n}`)
    .join(' || ')});
}`,
    ),
    '',
  ].join('\n'),
);
